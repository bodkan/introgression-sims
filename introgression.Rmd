---
output: github_document
---

```{r, include = FALSE}
options(readr.show_types = FALSE)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/",
  fig.width = 6,
  fig.height = 4,
  dpi = 80,
  eval = TRUE
)
```

# Simulating Neanderthal introgression data using *slendr*

Let's start by loading the *slendr* library (we install a development version from GitHub):

```{r}
devtools::install_github("bodkan/slendr")

SEED <- 314159265
set.seed(SEED)
```

```{r}
library(slendr)

# we also need to set the path to the Python environment containing
# msprime and tskit modules we use for tree sequence processing
reticulate::use_condaenv("retipy", required = TRUE)
```

Set the location for model configuration files and the output data directory:

```{r}
model_dir <- "./model"
output_dir <- "./results"

if (!dir.exists(output_dir)) dir.create(output_dir)
```

Let's specify the simplest possible introgression model with only three populations:

- one African population with $N_e = 10000$ (persisting from 650 kya to the present)
- one Neanderthal population with $N_e = 1000$ (becomes extinct at 40 kya)
- one "European" population -- no complex Eurasian history, a single uniform population with $N_e = 5000$

```{r}
afr <- population("AFR", time = 600e3, N = 10000)
nea <- population("NEA", time = 600e3, N = 1000, remove = 35e3)
eur1 <- population("EUR1", parent = afr, time = 70e3, N = 5000)
eur2 <- population("EUR2", parent = eur1, time = 45e3, N = 5000)
```

Neanderthal introgression into Europeans between 55-50 kya at 3%:

```{r}
prop1 <- 0.03
prop2 <- 0.01

gf <- list(
  gene_flow(from = nea, to = eur1, rate = prop1, start = 55000, end = 50000),
  gene_flow(from = nea, to = eur2, rate = prop2, start = 37000, end = 36000)
)
```

Compile the *slendr* model to a set configuration files which will be loaded by the SLiM backend script below:

```{r}
model <- compile_model(
  populations = list(nea, afr, eur1, eur2), gene_flow = gf,
  generation_time = 30,
  path = model_dir, overwrite = TRUE
)
```

```{r}
plot_model(model, proportions = TRUE)
```

Define a couple of individuals that will be "sampled" (i.e. explicitly remembered in the tree sequence with their complete genetic sequence):

- we will sample one Neanderthal 70 kya old (approximating the high-coverage "Altai" Neanderthal genome) and another one 40 ky old (approximating the high-coverage Neanderthal from the Vindija cave)
- 300 present-day Africans, 100 present-day Europeans
- a time-series of early-modern Europeans sampled between 30000 and 3000 kya, one individual every 1000 years

```{r}
nea_samples <- schedule_sampling(model, times = c(70000, 40000), list(nea, 1))
present_samples <- schedule_sampling(model, times = 0, list(afr, 300), list(eur1, 100), list(eur2, 100))
emh_samples <- schedule_sampling(model, times = seq(40000, 2000, by = -1000), list(eur1, 1), list(eur2, 1))

samples <- rbind(nea_samples, present_samples, emh_samples)
```

Finally we execute the simulation (we simulate 100Mb of sequence in each sampled individual, with the recombination rate $10^{-8}$ per bp per generation):

```{r}
ts <- slim(
  model, sequence_length = 100e6, recombination_rate = 1e-8,
  samples = samples, method = "batch", output = file.path(output_dir, "output_ts.trees"),
  verbose = TRUE, random_seed = SEED
)
```

## Loading and processing the tree sequence output

Let's load the tree sequence generated by SLiM under the hood,
[recapitate](https://pyslim.readthedocs.io/en/latest/tutorial.html#recapitation) it to
ensure coalescence of all genealogies in the tree sequence, and
[simplify](https://pyslim.readthedocs.io/en/latest/tutorial.html#simplification) it to
only nodes appearing as coalescence nodes somewhere in the genealogy of the explicitly
sampled individuals (or rather their chromosomes). At the same time, let's also sprinkle mutations on the tree sequence data structure (note that we did not simulate any mutations at all so far, which is why we can generate so much data for so many individuals in a forward simulation):

```{r, eval = FALSE}
model <- read(model_dir)
```

```{r}
ts <- ts_load(model, file = file.path(output_dir, "output_ts.trees"),
              recapitate = TRUE, Ne = 10000, recombination_rate = 1e-8,
              simplify = TRUE,
              mutate = TRUE, mutation_rate = 1e-8, random_seed = SEED,
              migration_matrix = list(c(0, 1, 0, 0),
                                      c(1, 0, 0, 0),
                                      c(0, 0, 0, 0),
                                      c(0, 0, 0, 0)))
```

## Sanity checks

First, let's check the contents of the tree sequence tables to make sure we have all the individuals we wanted to sample:

```{r}
ts_data(ts)
```

Then, just for fun, let's save the data as an EIGENSTRAT format used by ADMIXTOOLS. Here we are creating data with an added artificial outgroup "Chimp" (note that we didn't explicitly simulate chimpanzee lineage to save some time during simulation). This sample will have all ancestral alleles.

This command can take unfortunately quite long and takes quite a bit of memory, because we are extracting a matrix of all genotypes in the tree sequence and muging it a bit in R to be EIGENSTRAT compliant. This is very inefficient and will need some reimplementing to make it scalable... But it works reasonably OK (I can run it on my old laptop).

```{r}
prefix <- file.path(output_dir, "eigenstrat")

eigen_data <- ts_eigenstrat(ts, prefix = prefix, outgroup = "chimp")
```

Let's load [admixr](https://bodkan.net/admixr) (plus dplyr and ggplot2 for table munging and plotting) and do some quick sanity checks.

```{r}
library(admixr)
library(dplyr)
library(ggplot2)
library(purrr)
library(readr)
```

On a local machine (where we fetched the simulated data from the remote machine), we can run this instead of the `ts_eigenstrat` call above:

```{r}
prefix <- file.path(output_dir, "eigenstrat")

eigen_data <- eigenstrat(prefix)
```

Let's also extract the names (and ages) of all sampled individualsL

```{r}
samples <- ts_samples(ts)
```

First, $f_4(\textrm{African}_i, \textrm{African}_j, \textrm{Neanderthal}, \textrm{chimp})$ should
be zero (no introgression into any African) but $f_4(\textrm{African}_i, \textrm{European}_j,
\textrm{Neanderthal}, \textrm{chimp})$ should be significantly negative because of the genetic
affinity between Neanderthals and Europeans (we do this only for a subset of present-day individuals
to reduce computational time and memory). Furthermore, because the `r (eur2$pop)[1]` population
received an additional "pulse" of Neanderthal ancestry compared to the `r (eur1$pop)[1]` population,
it's $f_4$ value is even more negative.

```{r}
f4_result <-
  filter(samples, time == 0, pop %in% c("AFR", "EUR1", "EUR2")) %>%
  group_by(pop) %>%
  sample_n(25) %>%
  pull(name) %>%
  f4(W = "AFR_1", X = ., Y = "NEA_1", Z = "chimp", data = eigen_data)
```

```{r, f4_test, fig.width = 7, fig.height = 5}
inner_join(f4_result, samples, by = c("X" = "name")) %>%
  ggplot(aes(pop, f4, color = pop)) +
    geom_pointrange(aes(ymin = f4 - 2 * stderr, ymax = f4 + 2 * stderr, group = X),
                    position = position_dodge(width = 1)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.75) +
    geom_hline(yintercept = 0, linetype = 2) +
    theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
    ggtitle("f4(AFR1, <African or European>; Neanderthal, Chimp)",
            "Statistical test for the presence of Neanderthal ancestry")
```

Looks great! We can see that the Africans are all consistent with the hypothesis of no Neanderthal introgression (as expected, and as implied by the $f_4$ values around 0). On the other hand, we get significantly negative $f_4$ values for all European individuals, indicating that they carry evidence of Neanderthal introgression (we see significantly more "ABBA" sites than "BABA" sites).

Let's see how much Neanderthal ancestry we detect in Europeans (this is, of course, a different question than *if* we detect it). First let's use the `f4ratio` function in the *admixr* R package to perform the $f_4$-ratio estimate of Neanderhal ancestry:

```{r}
f4ratio_result <-
  filter(samples, pop %in% c("EUR1", "EUR2")) %>%
  pull(name) %>%
  f4ratio(X = ., A = "NEA_1", B = "NEA_2", C = "AFR_1", O = "chimp", data = eigen_data)
```

Now let's plot the time-series of Neanderthal ancestry estimates in simulated Europeans over time:

```{r, f4ratio_trajectory, fig.width = 7, fig.height = 5}
inner_join(f4ratio_result, samples, by = c("X" = "name")) %>%
filter(pop %in% c("EUR1", "EUR2")) %>%
  ggplot(aes(time, alpha)) +
    geom_pointrange(aes(ymin = alpha - 2 * stderr, ymax = alpha + 2 * stderr)) +
    geom_hline(yintercept = 0, linetype = 2) +
    geom_smooth(method = "lm") +
    coord_cartesian(ylim = c(0, 0.1)) +
    xlim(45000, 0) +
    facet_wrap(~ pop) +
    ggtitle("f4-ratio estimate of Neanderthal ancestry in Europeans over time") +
    labs(x = "time [years before present]", y = "Neanderhal ancestry proportion")
```

As expected, we see a constant level of Neanderthal ancestry around 3% (which is exactly
what we have simulated)!

Let's also check the amounts of Neanderthal ancestry in present-day Europeans and Asians:

```{r, f4ratio_boxplots, fig.width = 7, fig.height = 5}
inner_join(f4ratio_result, samples, by = c("X" = "name")) %>%
filter(time == 0) %>%
  ggplot(aes(pop, alpha, color = pop)) +
    geom_pointrange(aes(ymin = alpha - 2 * stderr, ymax = alpha + 2 * stderr, group = X),
                    position = position_dodge(width = 1)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.75) +
    geom_hline(yintercept = 0, linetype = 2) +
    theme(axis.text.x = element_blank(), axis.title.x = element_blank()) +
    ggtitle("f4-ratio estimate of Neanderthal ancestry in between Europe and Asia") +
    labs(y = "Neanderhal ancestry proportion")
```


## Save numeric identifiers of chromosomes for tree sequence processing

As can be seen from this notebook, thanks to the *slendr* interface, we can refer to individuals
(and their populations) with easy to read string names. However, the Jupyter notebook describing
detection of true Neanderthal fragments in simulated tree sequences (`detect_tracts.ipynb`) is
implemented in Python using native tskit Python interface which lacks this functionality. In the
following chunk, we will save a table of individual names together with the unique numerical IDs of
their chromosomes in the tree sequence. We will use this table in that Jupyter notebook for
assigning detected tracts to the correct individuals:

```{r}
node_table <-
  ts_data(ts, remembered = TRUE) %>%
  filter(pop %in% c("EUR1", "EUR2")) %>%
  as_tibble() %>%
  mutate(slim_id = map_int(node_id, ~ ts$node(as.integer(.x))$metadata["slim_id"])) %>%
  select(name, pop, time, slim_id)

write_tsv(node_table, "results/nodes.tsv")
```

## VCF output

Having made sure that the simulated data looks reasonable, we can save the simulated genotypes in a VCF format:

```{r}
ts_vcf(ts, path = file.path(output_dir, "output.vcf.gz"))
```

## How to run this pipeline

Of course, individual chunks can be run in an R console. The entire RMarkdown notebook can be rendered (simulations will be run, output files will be generated, and figures will be plotted) by typing `R -e 'rmarkdown::render("introgression.Rmd")'`.
